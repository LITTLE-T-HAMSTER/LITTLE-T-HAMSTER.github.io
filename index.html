<!DOCTYPE html>
<html>
<head>
    <title>Little_Mouse</title>
</head>
<body>
    <h1>01 Graph Theory</h1>
    <h2>BFS</h2>
    <h3>find distance</h3>
    <pre>
    int bfs_dis(int from, int to){ // Find distance between two point
      queue<int> que; bool vis[N];
      memset(vis, false, sizeof(vis)); que.push(start);
      while(!que.empty()){
        int node = que.front(); que.pop();
        if(node == to) return level[node];
        for(int next: graph[node]){
            if(!vis[next]){
                vis[next] = true;
                level[next] = level[node]+1;
                que.push(next);
            }
        }
      }
      return -1;
    }
  </pre>
  <h3>find distance in 2D</h3>
  <pre>
    class point{
    public:
        int x;
        int y;
    };
    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};
    int bfs_dis_2(point from, point des){ // Find the distance between two node
        int level[R][C]; queue<point> que; bool vis[R][C]; point tmp;
        memset(vis, false, sizeof(vis)); que.push(start); memset(level, 0, sizeof(level));
        while(!que.empty()){
            point node = que.front(); que.pop();
            if(node.x == des.x && node.y == des.y) return level[node.x][node.y];
            for(int i = 0; i < 4; i++){
                int nx = node.x+dx[i]; int ny = node.y+dy[i];
                if(nx >= 0 && nx < R && ny >= 0 && ny < C && !vis[nx][ny]){ // Can add more(e.g. grid[nx][ny] != 'X')
                    vis[nx][ny] = true;
                    tmp.x = nx; tmp.y = ny;
                    que.push(tmp);
                    level[nx][ny] = level[node.x][node.y]+1;
                }
            }
        }
        return -1;
    }
  </pre>
  <h2>DFS</h2>
  <h3>find distance</h3>
  <pre>
  #include <bits/stdc++.h>
  using namespace std;
  queue<int> que;
  vector<vector<int>> graph;
  int vis;
  int level;
  int dfs_dis(int cur, int des, int dis){
      if(cur == des) return level = dis;
      vis[cur] = true; que.push(cur);
      for(int next: graph[cur]){
          if(!vis[next]) dfs_dis(next, des, dis+1);
      }
      return level;
  }
  int main(){
      memset(vis, false, sizeof(vis));
      graph[1].push_back(2);
      graph[4].push_back(5);
      graph[2].push_back(3);
      cout << dfs_dis(1,3,0) << endl;
      return 0;
  }
  </pre>
  <h3>count numbers of room</h3>
  <pre>
  void count_rooms(int r, int c) {
    grid[r][c] = 'X'; // change 'X' to the wall in the specific question
    // go up
    if(r > 0 && grid[r-1][c] == '.') count_rooms(r-1, c);
    // go down
    if(r < R-1 && grid[r+1][c] == '.') count_rooms(r+1, c);
    // go left
    if(c > 0 && grid[r][c-1] == '.') count_roomsd(r, c-1);
    // go right
    if(c < C-1 && grid[r][c+1] == '.') count_rooms(r, c+1);
  }
  int main() {
      cin >> R >> C;
      for(int i = 0; i < R; i++) {
          for(int j = 0; j < C; j++) {
              cin >> grid[i][j];
          }
      }
      int cnt = 0;
      for(int i = 0; i < R; i++) {
          for(int j = 0; j < C; j++) {
              if(grid[i][j] == '.') {
                  count_rooms(i, j);
                  cnt++;
              }
          }
      }
      cout << cnt << "\n";
      return 0;
  }
</pre>
  <h2>DSU<h2>
  <h3>template dsu (with rank)</h3>
    <pre>
    class dsu{
    public:
        int* parent;
        int* ranks;
        int n;
        mst(int N){
            parent = new int[N+1];
            ranks = new int[N+1];
            n = N;
            init();
        }
        void init(){
            for(int i=0; i<=n; i++){
                parent[i] = i;
                ranks[i] = 0;
            }
        }
        int find_parent(int node){
            if(parent[node] != node)
                return parent[node] = find_parent(parent[node]);
            return parent[node];
        }
        bool same_parent(int a, int b){
            return find_parent(a) == find_parent(b);
        }
        void union_parent(int a, int b){
            int parent_a = find_parent(a), parent_b = find_parent(b);
            if(parent_a == parent_b) return; // Same tree
            else if(ranks[parent_a] < ranks[parent_b]){ // B is deeper
                parent[parent_a] = parent_b;
            }
            else if(ranks[parent_b] < ranks[parent_a]){ // A is deeper
                parent[parent_b] = parent_a;
            }
            else{ // Same deep
                parent[parent_b] = parent_a;
                ranks[parent_a]++;
            }
        }
    };
    </pre>
    <h2>Topologicial Sort</h2>
    <h3>template topologicial sort</h3>
    <pre>
    #include <bits/stdc++.h>
    using namespace std;
    // Author: Little_Mouse
    // Direct Graph
    // v can go to u, then u before v
    vector<vector<int>> graph;
    int* indegree; int N;
    vector<int> sortednode;
    void topologicial_sort(){
        queue<int> que;
        int cnt = 0;
        for(int i=0; i < N; i++){
            if(indegree[i]==0) que.push(i);
        }
        while(!que.empty()){
            int cur = que.front(); que.pop(); cnt++; sortednode.push_back(cur);
            for(int nxt: graph[cur]) {
                indegree[nxt]--;
                if(indegree[nxt]==0) que.push(nxt);
            }
        }
    }
    int main() {
        //cin >> N; < - input
        N = 6;
        graph.resize(N);
        // Node 0
        // N/A
        // Node 1
        graph[1].push_back(0);
        graph[1].push_back(3);
        // Node 2
        graph[2].push_back(0);
        graph[2].push_back(3);
        // Node 3
        graph[3].push_back(0);
        graph[3].push_back(5);
        // Node 4
        graph[4].push_back(2);
        graph[4].push_back(3);
        graph[4].push_back(5);
        // Node 5
        // N/A
        indegree = new int[N];
        for(int i=0; i < N; i++) indegree[i]=0;
        for(int i=0; i < N; i++){
            for(int to: graph[i]){
                indegree[to]++;
            }
        }
        for(int i=0; i < N; i++){
            cout << "Node " << i << " can be access from " << indegree[i] << " node(s)" << endl;
        }
        topologicial_sort();
        cout << "After Sort: ";
        for(int i=0; i < sortednode.size(); i++){
            cout << sortednode[i] << " ";
        }
        cout << "\n";
        return 0;
    }
    <a href="https://imgbb.com/"><img src="https://i.ibb.co/rGRd7tB/topological-sort.png" alt="topological sort" border="0"></a>
  </pre>
</body>
</html>
